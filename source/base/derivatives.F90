module derivatives
  !! This module contains routines to calculate various derivatives
  !! using weightings generated by LABFM. It should be the only
  !! module in the code which performs loops over neighbours during
  !! the simulation.
  !! N.B. Reformulated with ij_sums to improve efficiency. Only one + and *
  !! used within inner loops.
  use kind_parameters
  use common_parameter
  use common_vars
  use omp_lib
  implicit none

contains
  subroutine calc_gradient(phi,gradphi)
    !! Calculate the gradient of scalar phi.
    real(rkind),dimension(:,:),intent(in) :: phi
    real(rkind),dimension(:,:,:),intent(inout) :: gradphi
    integer :: i,j,k,ik,jk
    real(rkind),dimension(dims) :: gradtmp
    real(rkind) :: gradztmp
        
    !$OMP PARALLEL DO PRIVATE(j,k,gradtmp,ik,jk)
    do i=1,nx
       do j=1,ny
          gradtmp=zero
          
          do k=1,9
             ik=fd_link_x(i,k) !! x-index of neighbour
             gradtmp(1) = gradtmp(1) + phi(ik,j)*fd_grad_x(i,k)
             
             jk=fd_link_y(j,k) !! y-index of neighbour            
             gradtmp(2) = gradtmp(2) + phi(i,jk)*fd_grad_y(j,k)
          end do       
          gradphi(i,j,:) = gradtmp(:)
       end do
    end do
    !$OMP END PARALLEL DO
      

    return
  end subroutine calc_gradient
!! ------------------------------------------------------------------------------------------------
  subroutine calc_ddy_of_ddx(dphidx,d2phidxdy)
    !! Calculate the gradient of scalar phi.
    real(rkind),dimension(:,:),intent(in) :: dphidx
    real(rkind),dimension(:,:),intent(inout) :: d2phidxdy
    integer :: i,j,k,ik,jk
    real(rkind) :: gradtmp
        
    !$OMP PARALLEL DO PRIVATE(j,k,gradtmp,jk)
    do i=1,nx
       do j=1,ny
          gradtmp=zero
          
          do k=1,9
             jk=fd_link_y(j,k) !! y-index of neighbour            
             gradtmp = gradtmp + dphidx(i,jk)*fd_grad_y(j,k)
          end do       
          d2phidxdy(i,j) = gradtmp
       end do
    end do
    !$OMP END PARALLEL DO
      

    return
  end subroutine calc_ddy_of_ddx  
  
!! ------------------------------------------------------------------------------------------------
  subroutine calc_divergence(phi1,phi2,divphi)
    !! Calculate the gradient of scalar phi.
    real(rkind),dimension(:,:),intent(in) :: phi1,phi2
    real(rkind),dimension(:,:),intent(inout) :: divphi
    integer :: i,j,k,ik,jk
    real(rkind) :: divtmp
        
    !$OMP PARALLEL DO PRIVATE(j,k,divtmp,ik,jk)
    do i=1,nx
       do j=1,ny
          divtmp=zero
          
          do k=1,9
             ik=fd_link_x(i,k) !! x-index of neighbour
             divtmp = divtmp + phi1(ik,j)*fd_grad_x(i,k)
             
             jk=fd_link_y(j,k) !! y-index of neighbour            
             divtmp = divtmp + phi2(i,jk)*fd_grad_y(j,k)
          end do       
          divphi(i,j) = divtmp
       end do
    end do
    !$OMP END PARALLEL DO
      

    return
  end subroutine calc_divergence
!! ------------------------------------------------------------------------------------------------  
  subroutine calc_laplacian(phi,lapphi)
    !! Calculate the Laplacian of a scalar phi
    real(rkind),dimension(:,:),intent(in) :: phi
    real(rkind),dimension(:,:),intent(inout) :: lapphi
    integer i,j,k,ik,jk
    real(rkind) :: lap_tmp

    !$OMP PARALLEL DO PRIVATE(j,k,lap_tmp,ik,jk)
    do i=1,nx
       do j=1,ny
          lap_tmp = zero
          do k=1,9
             ik=fd_link_x(i,k) !! x-index of neighbour
             lap_tmp = lap_tmp + phi(ik,j)*fd_grad2_x(i,k)
             
             jk=fd_link_y(j,k) !! y-index of neighbour
             lap_tmp = lap_tmp + phi(i,jk)*fd_grad2_y(j,k)
          end do
          lapphi(i,j) = lap_tmp
       end do
    end do
    !$OMP END PARALLEL DO
      

  end subroutine calc_laplacian
!! ------------------------------------------------------------------------------------------------       
  subroutine calc_filtered_var(phi)
    !! 8th order filters, dropping to 4th order at boundaries
    !! Note in FD schemes, we have to do the coordinates sequentially
    real(rkind),dimension(:,:),intent(inout) :: phi
    real(rkind),dimension(:,:),allocatable :: filtphi
    integer i,j,k,ik,jk
    real(rkind) :: hyp_tmp

    !! Allocate temporary store
    allocate(filtphi(nx,ny));filtphi=zero

    !! Filter in x
    !$OMP PARALLEL DO PRIVATE(j,k,hyp_tmp,ik)
    do i=1,nx
       do j=1,ny
          hyp_tmp=zero
            
          do k=1,9
             ik=fd_link_x(i,k) !! x-index of neighbour
             hyp_tmp = hyp_tmp + phi(ik,j)*fd_hyp_x(i,k)             
          end do
          filtphi(i,j) = phi(i,j) + hyp_tmp
       end do
    end do
    !$OMP END PARALLEL DO 
    
    !! Pass filtered phi back to phi    
    phi(1:nx,1:ny)=filtphi(1:nx,1:ny)    
    
    !! Filter in y
    !$OMP PARALLEL DO PRIVATE(j,k,hyp_tmp,jk)
    do i=1,nx
       do j=1,ny
          hyp_tmp=zero
            
          do k=1,9           
             jk=fd_link_y(j,k) !! y-index of neighbour
             hyp_tmp = hyp_tmp + phi(i,jk)*fd_hyp_y(j,k)
          end do
          filtphi(i,j) = phi(i,j) + hyp_tmp
       end do
    end do
    !$OMP END PARALLEL DO 
    
    !! Pass filtered phi back to phi    
    phi(1:nx,1:ny)=filtphi(1:nx,1:ny)        

    deallocate(filtphi)

    return
  end subroutine calc_filtered_var     
!! ------------------------------------------------------------------------------------------------     
end module derivatives
